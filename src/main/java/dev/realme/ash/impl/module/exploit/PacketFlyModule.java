package dev.realme.ash.impl.module.exploit;

import dev.realme.ash.api.config.Config;
import dev.realme.ash.api.config.setting.BooleanConfig;
import dev.realme.ash.api.config.setting.EnumConfig;
import dev.realme.ash.api.config.setting.NumberConfig;
import dev.realme.ash.api.event.EventStage;
import dev.realme.ash.api.event.listener.EventListener;
import dev.realme.ash.api.module.ModuleCategory;
import dev.realme.ash.api.module.ToggleModule;
import dev.realme.ash.impl.event.ScreenOpenEvent;
import dev.realme.ash.impl.event.TickEvent;
import dev.realme.ash.impl.event.entity.player.PlayerMoveEvent;
import dev.realme.ash.impl.event.network.DisconnectEvent;
import dev.realme.ash.impl.event.network.PacketEvent;
import dev.realme.ash.impl.event.network.PushOutOfBlocksEvent;
import dev.realme.ash.impl.event.network.UpdateWalkingEvent;
import dev.realme.ash.init.Managers;
import dev.realme.ash.mixin.accessor.AccessorPlayerPositionLookS2CPacket;
import dev.realme.ash.util.Globals;
import dev.realme.ash.util.math.position.TimedVec3d;
import dev.realme.ash.util.string.EnumFormatter;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;
import net.minecraft.client.gui.screen.DeathScreen;
import net.minecraft.client.gui.screen.DownloadingTerrainScreen;
import net.minecraft.network.packet.Packet;
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
import net.minecraft.network.packet.c2s.play.TeleportConfirmC2SPacket;
import net.minecraft.network.packet.s2c.play.PlayerPositionLookS2CPacket;
import net.minecraft.network.packet.s2c.play.PositionFlag;
import net.minecraft.util.math.Vec2f;
import net.minecraft.util.math.Vec3d;

public class PacketFlyModule
extends ToggleModule {
    final Config<FlyMode> modeConfig = new EnumConfig<>("Mode", "The packetfly mode for spoofing packets", FlyMode.FAST, FlyMode.values());
    final Config<Float> factorConfig = new NumberConfig<>("Factor", "The tick factor when applying packets", 1.0f, 1.0f, 10.0f, () -> this.modeConfig.getValue() == FlyMode.FACTOR);
    final Config<Float> reductionConfig = new NumberConfig<>("Reduction", "The reduction vertical factor", 0.0f, 0.0f, 2.5f);
    final Config<Phase> phaseConfig = new EnumConfig<>("Phase", "The phase/noclip type for moving through blocks", Phase.FULL, Phase.values());
    final Config<Type> typeConfig = new EnumConfig<>("Type", "The out of bounds packet type", Type.DOWN, Type.values());
    final Config<Limit> limitConfig = new EnumConfig<>("Limit", "The horizontal speed limit", Limit.OFF, Limit.values());
    final Config<Boolean> verticalLimitConfig = new BooleanConfig("Limit-Vertical", "Slows down when moving vertically", false);
    final Config<Boolean> concealConfig = new BooleanConfig("Conceal", "Conceals the out of bounds packet", false);
    final Config<Boolean> limitJitterConfig = new BooleanConfig("LimitJitter", "Prevents the jitter when flying", true);
    final Config<Boolean> slowConfig = new BooleanConfig("Conceal-Slow", "Slows down the speed to the concealed speed", false);
    final Config<Boolean> antiKickConfig = new BooleanConfig("AntiKick", "Prevents the vanilla anticheat from kicking for flying", true);
    private int limitTicks;
    private boolean limitSpeed;
    private int antiKickTicks;
    private int teleportId;
    private boolean concealTeleportPacket;
    private static final float CONCEAL_SPEED = 0.0624f;
    private static final double MOVE_FACTOR = 1.0 / Math.sqrt(2.0);
    private final Set<PlayerMoveC2SPacket> clientPositionPackets = new HashSet<>();
    private final ConcurrentMap<Integer, TimedVec3d> serverPositionPredictions = new ConcurrentHashMap<>();

    public PacketFlyModule() {
        super("PacketFly", "Allows player to fly by abusing 1.9+ packet exploit", ModuleCategory.EXPLOITS);
    }

    @Override
    public String getModuleData() {
        return EnumFormatter.formatEnum(this.modeConfig.getValue());
    }

    @Override
    public void onDisable() {
        if (PacketFlyModule.mc.player == null) {
            return;
        }
        this.serverPositionPredictions.clear();
        this.teleportId = 0;
        PacketFlyModule.mc.player.noClip = false;
    }

    @EventListener
    public void onDisconnect(DisconnectEvent event) {
        this.disable();
    }

    @EventListener
    public void onScreenOpen(ScreenOpenEvent event) {
        if (event.getScreen() instanceof DeathScreen) {
            this.disable();
        }
    }

    @EventListener
    public void onPacketOutbound(PacketEvent.Send event) {
        PlayerMoveC2SPacket packet;
        Packet<?> packet2 = event.getPacket();
        if (packet2 instanceof PlayerMoveC2SPacket && !this.clientPositionPackets.contains(packet = (PlayerMoveC2SPacket) packet2) && !mc.isInSingleplayer()) {
            event.cancel();
        }
    }

    @EventListener
    public void onPacketInbound(PacketEvent.Receive event) {
        if (PacketFlyModule.mc.player == null || PacketFlyModule.mc.world == null || mc.isInSingleplayer() || PacketFlyModule.mc.currentScreen instanceof DownloadingTerrainScreen) {
            return;
        }
        Packet<?> packet = event.getPacket();
        if (packet instanceof PlayerPositionLookS2CPacket) {
            PlayerPositionLookS2CPacket packet2 = (PlayerPositionLookS2CPacket) packet;
            TimedVec3d predictPos = this.serverPositionPredictions.remove(packet2.getTeleportId());
            if (predictPos != null && predictPos.getX() == packet2.getX() && predictPos.getY() == packet2.getY() && predictPos.getZ() == packet2.getZ()) {
                if (this.modeConfig.getValue() != FlyMode.SETBACK) {
                    event.cancel();
                }
                Managers.NETWORK.sendPacket(new TeleportConfirmC2SPacket(packet2.getTeleportId()));
                return;
            }
            if (this.concealConfig.getValue() && predictPos != null && (predictPos.getX() != packet2.getX() || predictPos.getY() != packet2.getY() || predictPos.getZ() != packet2.getZ())) {
                this.concealTeleportPacket = true;
            }
            packet2.getFlags().remove(PositionFlag.X_ROT);
            packet2.getFlags().remove(PositionFlag.Y_ROT);
            ((AccessorPlayerPositionLookS2CPacket) packet2).setYaw(PacketFlyModule.mc.player.getYaw());
            ((AccessorPlayerPositionLookS2CPacket) packet2).setPitch(PacketFlyModule.mc.player.getPitch());
            Managers.NETWORK.sendPacket(new TeleportConfirmC2SPacket(packet2.getTeleportId()));
            this.teleportId = packet2.getTeleportId();
        }
    }

    @EventListener
    public void onPlayerUpdate(UpdateWalkingEvent event) {
        double motionY;
        if (event.getStage() != EventStage.PRE) {
            return;
        }
        if (this.modeConfig.getValue() != FlyMode.SETBACK && this.teleportId == 0 && !mc.isInSingleplayer()) {
            if (this.checkAntiKick(4)) {
                Vec3d playerPos = PacketFlyModule.mc.player.getPos();
                this.sendMovePacket(playerPos);
                if (this.concealTeleportPacket && this.concealConfig.getValue()) {
                    this.sendMovePacket(this.getConcealVec(playerPos));
                    this.concealTeleportPacket = false;
                }
                this.sendMovePacket(this.typeConfig.getValue().getOutOfBoundsVec3d(playerPos));
                if (this.modeConfig.getValue() != FlyMode.SETBACK) {
                    this.serverPositionPredictions.put(++this.teleportId, new TimedVec3d(playerPos, System.currentTimeMillis()));
                    if (this.limitJitterConfig.getValue()) {
                        Managers.NETWORK.sendPacket(new TeleportConfirmC2SPacket(this.teleportId));
                    }
                }
            }
            return;
        }
        boolean blockPhased = this.isBlockPhased();
        float moveSpeed = this.slowConfig.getValue() || this.phaseConfig.getValue() == Phase.FULL && blockPhased ? 0.031f : this.getLimitedSpeed();
        boolean antiKick = false;
        if (PacketFlyModule.mc.options.jumpKey.isPressed()) {
            if (this.antiKickConfig.getValue() && !blockPhased) {
                antiKick = this.checkAntiKick(this.modeConfig.getValue() == FlyMode.SETBACK ? 10 : 20) && PacketFlyModule.mc.player.forwardSpeed == 0.0f && PacketFlyModule.mc.player.sidewaysSpeed == 0.0f;
                double d = motionY = antiKick ? -0.032 : (double)0.0624f;
                if (this.verticalLimitConfig.getValue() && (PacketFlyModule.mc.player.forwardSpeed != 0.0f || PacketFlyModule.mc.player.sidewaysSpeed != 0.0f)) {
                    moveSpeed = (float)((double)moveSpeed * MOVE_FACTOR);
                    motionY *= MOVE_FACTOR;
                }
            } else {
                motionY = 0.0624f;
                if (this.verticalLimitConfig.getValue() && (PacketFlyModule.mc.player.forwardSpeed != 0.0f || PacketFlyModule.mc.player.sidewaysSpeed != 0.0f)) {
                    moveSpeed = (float)((double)moveSpeed * MOVE_FACTOR);
                    motionY *= MOVE_FACTOR;
                }
            }
        } else if (PacketFlyModule.mc.options.sneakKey.isPressed()) {
            motionY = -0.0624f;
            if (this.verticalLimitConfig.getValue() && (PacketFlyModule.mc.player.forwardSpeed != 0.0f || PacketFlyModule.mc.player.sidewaysSpeed != 0.0f)) {
                moveSpeed = (float)((double)moveSpeed * MOVE_FACTOR);
                motionY *= MOVE_FACTOR;
            }
        } else if (!blockPhased && this.antiKickConfig.getValue()) {
            antiKick = this.checkAntiKick(4) && PacketFlyModule.mc.player.forwardSpeed == 0.0f && PacketFlyModule.mc.player.sidewaysSpeed == 0.0f;
            motionY = antiKick ? -0.04 : 0.0;
        } else {
            motionY = 0.0;
        }
        if (this.phaseConfig.getValue() == Phase.FULL && blockPhased && motionY != 0.0) {
            motionY /= 2.5 + (double) this.reductionConfig.getValue();
        }
        Vec2f motion = this.handleFlightMotion(moveSpeed);
        for (int i = 1; i <= (this.modeConfig.getValue() == FlyMode.FACTOR ? this.factorConfig.getValue().intValue() : 1); ++i) {
            double motionX = motion.x * (float)i;
            double motionZ = motion.y * (float)i;
            if (!antiKick) {
                motionY *= i;
            }
            PacketFlyModule.mc.player.setVelocity(motionX, motionY, motionZ);
            if (mc.isInSingleplayer()) continue;
            Vec3d pos = PacketFlyModule.mc.player.getPos();
            Vec3d move = pos.add(motionX, motionY, motionZ);
            this.sendMovePacket(move);
            if (this.concealTeleportPacket && this.concealConfig.getValue()) {
                this.sendMovePacket(this.getConcealVec(move));
                this.concealTeleportPacket = false;
            }
            this.sendMovePacket(this.typeConfig.getValue().getOutOfBoundsVec3d(move));
            if (this.modeConfig.getValue() == FlyMode.SETBACK) continue;
            this.serverPositionPredictions.put(++this.teleportId, new TimedVec3d(move, System.currentTimeMillis()));
            Managers.NETWORK.sendPacket(new TeleportConfirmC2SPacket(this.teleportId));
        }
    }

    @EventListener
    public void onPlayerMove(PlayerMoveEvent event) {
        if (PacketFlyModule.mc.player == null) {
            return;
        }
        Vec3d move = PacketFlyModule.mc.player.getVelocity();
        event.setX(move.x);
        event.setY(move.y);
        event.setZ(move.z);
        if (this.phaseConfig.getValue() != Phase.OFF) {
            PacketFlyModule.mc.player.noClip = true;
        }
        event.cancel();
    }

    @EventListener
    public void onTick(TickEvent event) {
        if (event.getStage() != EventStage.PRE) {
            return;
        }
        this.serverPositionPredictions.entrySet().removeIf(pos -> {
            TimedVec3d timeVec = pos.getValue();
            long elapsed = System.currentTimeMillis() - timeVec.time();
            return elapsed > TimeUnit.SECONDS.toMillis(30L);
        });
    }

    @EventListener
    public void onPushOutOfBlocks(PushOutOfBlocksEvent event) {
        event.cancel();
    }

    private void sendMovePacket(Vec3d vec) {
        PlayerMoveC2SPacket.PositionAndOnGround packet = new PlayerMoveC2SPacket.PositionAndOnGround(vec.getX(), vec.getY(), vec.getZ(), PacketFlyModule.mc.player.isOnGround());
        Managers.NETWORK.sendPacket(packet);
        this.clientPositionPackets.add(packet);
    }

    private Vec3d getConcealVec(Vec3d vec) {
        return new Vec3d(vec.x, RANDOM.nextDouble(278.0, 295.0) * (vec.y > 127.5 ? -1.0 : 1.0), vec.z);
    }

    private float getLimitedSpeed() {
        return switch (this.limitConfig.getValue()) {
            case TICK -> 0.1899f;
            case SPEED -> {
                if (!this.limitSpeed) {
                    if (this.checkLimitSpeed(7)) {
                        this.limitSpeed = true;
                    }
                    yield 0.253f;
                }
                if (this.checkLimitSpeed(7)) {
                    this.limitSpeed = false;
                }
                yield 0.198f;
            }
            case BOTH -> {
                if (!this.limitSpeed) {
                    if (this.checkLimitSpeed(1)) {
                        this.limitSpeed = true;
                    }
                    yield 0.256f;
                }
                if (this.checkLimitSpeed(1)) {
                    this.limitSpeed = false;
                }
                yield 0.1899f;
            }
            case OFF -> 0.26f;
        };
    }

    private Vec2f handleFlightMotion(float speed) {
        float forward = PacketFlyModule.mc.player.input.movementForward;
        float strafe = PacketFlyModule.mc.player.input.movementSideways;
        float yaw = PacketFlyModule.mc.player.prevYaw + (PacketFlyModule.mc.player.getYaw() - PacketFlyModule.mc.player.prevYaw) * mc.getTickDelta();
        if (forward == 0.0f && strafe == 0.0f) {
            return Vec2f.ZERO;
        }
        if (forward != 0.0f) {
            if (strafe >= 1.0f) {
                yaw += forward > 0.0f ? -45.0f : 45.0f;
                strafe = 0.0f;
            } else if (strafe <= -1.0f) {
                yaw += forward > 0.0f ? 45.0f : -45.0f;
                strafe = 0.0f;
            }
            if (forward > 0.0f) {
                forward = 1.0f;
            } else if (forward < 0.0f) {
                forward = -1.0f;
            }
        }
        float rx = (float)Math.cos(Math.toRadians(yaw));
        float rz = (float)(-Math.sin(Math.toRadians(yaw)));
        return new Vec2f(forward * speed * rz + strafe * speed * rx, forward * speed * rx - strafe * speed * rz);
    }

    private boolean checkAntiKick(int ticks) {
        if (++this.antiKickTicks >= ticks) {
            this.antiKickTicks = 0;
            return true;
        }
        return false;
    }

    private boolean checkLimitSpeed(int ticks) {
        if (++this.limitTicks >= ticks) {
            this.limitTicks = 0;
            return true;
        }
        return false;
    }

    private boolean isBlockPhased() {
        return !PacketFlyModule.mc.world.isSpaceEmpty(PacketFlyModule.mc.player, PacketFlyModule.mc.player.getBoundingBox().expand(-0.0625, -0.0625, -0.0625));
    }

    public enum FlyMode {
        FACTOR,
        FAST,
        SETBACK

    }

    public enum Phase {
        FULL,
        SEMI,
        OFF

    }

    /*
     * Uses 'sealed' constructs - enablewith --sealed true
     */
    public enum Type {
        UP{

            @Override
            public Vec3d getOutOfBoundsVec3d(Vec3d vec) {
                return vec.subtract(0.0, 1337.0, 0.0);
            }
        }
        ,
        DOWN{

            @Override
            public Vec3d getOutOfBoundsVec3d(Vec3d vec) {
                return vec.add(0.0, 1337.0, 0.0);
            }
        }
        ,
        PRESERVE{

            @Override
            public Vec3d getOutOfBoundsVec3d(Vec3d vec) {
                return vec.add(Globals.RANDOM.nextDouble(100000.0), 0.0, Globals.RANDOM.nextDouble(100000.0));
            }
        }
        ,
        PRESERVE_BOUNDED{

            @Override
            public Vec3d getOutOfBoundsVec3d(Vec3d vec) {
                return Vec3d.ZERO;
            }
        }
        ,
        BOUNDED{

            @Override
            public Vec3d getOutOfBoundsVec3d(Vec3d vec) {
                return new Vec3d(vec.x, -vec.y + (vec.y < 127.5 ? 255.0 : 0.0), vec.z);
            }
        }
        ,
        CONCEAL{

            @Override
            public Vec3d getOutOfBoundsVec3d(Vec3d vec) {
                return vec.add(Globals.RANDOM.nextDouble(-100000.0, 100000.0), 2.0, Globals.RANDOM.nextDouble(-100000.0, 100000.0));
            }
        }
        ,
        LIMIT{

            @Override
            public Vec3d getOutOfBoundsVec3d(Vec3d vec) {
                return vec.add(Globals.RANDOM.nextDouble(-50.0, 50.0), Globals.RANDOM.nextDouble(50.0, 80.0) * (Globals.RANDOM.nextBoolean() ? 1.0 : -1.0), Globals.RANDOM.nextDouble(-50.0, 50.0));
            }
        }
        ,
        LIMIT_JITTER{

            @Override
            public Vec3d getOutOfBoundsVec3d(Vec3d vec) {
                return vec.add(Globals.RANDOM.nextDouble(-10.0, 10.0), Globals.RANDOM.nextDouble(80.0, 100.0) * (Globals.RANDOM.nextBoolean() ? 1.0 : -1.0), Globals.RANDOM.nextDouble(-10.0, 10.0));
            }
        };


        public abstract Vec3d getOutOfBoundsVec3d(Vec3d var1);
    }

    public enum Limit {
        TICK,
        SPEED,
        BOTH,
        OFF

    }
}
