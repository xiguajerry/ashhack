package dev.realme.ash.impl.module.exploit;

import dev.realme.ash.api.config.Config;
import dev.realme.ash.api.config.setting.BooleanConfig;
import dev.realme.ash.api.config.setting.EnumConfig;
import dev.realme.ash.api.config.setting.NumberConfig;
import dev.realme.ash.api.event.EventStage;
import dev.realme.ash.api.event.listener.EventListener;
import dev.realme.ash.api.module.ModuleCategory;
import dev.realme.ash.api.module.RotationModule;
import dev.realme.ash.impl.event.network.PushOutOfBlocksEvent;
import dev.realme.ash.impl.event.network.UpdateWalkingEvent;
import dev.realme.ash.impl.event.world.BlockCollisionEvent;
import dev.realme.ash.init.Managers;
import dev.realme.ash.util.player.InventoryUtil;
import dev.realme.ash.util.player.MovementUtil;
import dev.realme.ash.util.string.EnumFormatter;
import net.minecraft.item.Items;
import net.minecraft.network.packet.c2s.play.PlayerInteractItemC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
import net.minecraft.util.Hand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.shape.VoxelShapes;

public class PhaseModule
extends RotationModule {
    Config<SwapMode> swapMode = new EnumConfig("SwapMode", "", SwapMode.SILENT, SwapMode.values());
    Config<PhaseMode> modeConfig = new EnumConfig("Mode", "The phase mode for clipping into blocks", PhaseMode.NORMAL, PhaseMode.values());
    Config<Integer> pitchConfig = new NumberConfig<Integer>("Pitch", "The pitch to throw pearls", 70, 85, 90, () -> this.modeConfig.getValue() == PhaseMode.PEARL);
    Config<Float> blocksConfig = new NumberConfig<Float>("Blocks", "The blocks distance to phase clip", 0.001f, 0.003f, 10.0f, () -> this.modeConfig.getValue() != PhaseMode.PEARL);
    Config<Float> distanceConfig = new NumberConfig<Float>("Distance", "The distance to phase", 0.0f, 0.2f, 10.0f, () -> this.modeConfig.getValue() != PhaseMode.PEARL);
    Config<Boolean> autoClipConfig = new BooleanConfig("AutoClip", "Automatically clips into the block", true);

    public PhaseModule() {
        super("Phase", "Allows player to phase through solid blocks", ModuleCategory.EXPLOITS, 1000);
    }

    @Override
    public String getModuleData() {
        return EnumFormatter.formatEnum(this.modeConfig.getValue());
    }

    @Override
    public void onEnable() {
        if (PhaseModule.mc.player == null) {
            return;
        }
        if (this.modeConfig.getValue() == PhaseMode.PEARL) {
            int slot = this.findPearlSlot();
            if (slot == -1 || PhaseModule.mc.player.getItemCooldownManager().isCoolingDown(Items.ENDER_PEARL)) {
                this.disable();
                return;
            }
            int prevSlot = PhaseModule.mc.player.getInventory().selectedSlot;
            switch (this.swapMode.getValue()) {
                case SILENT: 
                case NORMAL: {
                    InventoryUtil.doSwap(slot);
                    break;
                }
                case Inventory: {
                    InventoryUtil.doInvSwap(slot);
                    break;
                }
                case Pick: {
                    InventoryUtil.doPickSwap(slot);
                }
            }
            Managers.NETWORK.sendPacket(new PlayerMoveC2SPacket.LookAndOnGround(this.getYaw(), this.pitchConfig.getValue().intValue(), Managers.POSITION.isOnGround()));
            Managers.NETWORK.sendSequencedPacket(id -> new PlayerInteractItemC2SPacket(Hand.MAIN_HAND, id));
            switch (this.swapMode.getValue()) {
                case SILENT: {
                    InventoryUtil.doSwap(prevSlot);
                    break;
                }
                case Inventory: {
                    InventoryUtil.doInvSwap(slot);
                    break;
                }
                case Pick: {
                    InventoryUtil.doPickSwap(slot);
                }
            }
            this.disable();
        } else if (this.autoClipConfig.getValue().booleanValue()) {
            double cos = Math.cos(Math.toRadians(PhaseModule.mc.player.getYaw() + 90.0f));
            double sin = Math.sin(Math.toRadians(PhaseModule.mc.player.getYaw() + 90.0f));
            PhaseModule.mc.player.setPosition(PhaseModule.mc.player.getX() + (1.0 * (double)this.blocksConfig.getValue().floatValue() * cos + 0.0 * (double)this.blocksConfig.getValue().floatValue() * sin), PhaseModule.mc.player.getY(), PhaseModule.mc.player.getZ() + (1.0 * (double)this.blocksConfig.getValue().floatValue() * sin - 0.0 * (double)this.blocksConfig.getValue().floatValue() * cos));
        }
    }

    private int getYaw() {
        return (int)Math.round(PhaseModule.getYaw(new Vec3d(Math.floor(PhaseModule.mc.player.getX()) + 0.5, 0.0, Math.floor(PhaseModule.mc.player.getZ()) + 0.5))) + 180;
    }

    public static double getYaw(Vec3d pos) {
        return PhaseModule.mc.player.getYaw() + MathHelper.wrapDegrees((float)Math.toDegrees(Math.atan2(pos.getZ() - PhaseModule.mc.player.getZ(), pos.getX() - PhaseModule.mc.player.getX())) - 90.0f - PhaseModule.mc.player.getYaw());
    }

    private int findPearlSlot() {
        return switch (this.swapMode.getValue()) {
            case SILENT, NORMAL -> InventoryUtil.findItem(Items.ENDER_PEARL);
            case Inventory -> InventoryUtil.findInventorySlot(Items.ENDER_PEARL, false);
            case Pick -> InventoryUtil.findInventorySlot(Items.ENDER_PEARL, true);
            default -> -1;
        };
    }

    @EventListener
    public void onBlockCollision(BlockCollisionEvent event) {
        if (PhaseModule.mc.player == null) {
            return;
        }
        switch (this.modeConfig.getValue()) {
            case NORMAL: {
                if (event.getVoxelShape() == VoxelShapes.empty() || !(event.getVoxelShape().getBoundingBox().maxY > PhaseModule.mc.player.getBoundingBox().minY) || !PhaseModule.mc.player.isSneaking()) break;
                event.cancel();
                event.setVoxelShape(VoxelShapes.empty());
                break;
            }
            case SAND: {
                event.cancel();
                event.setVoxelShape(VoxelShapes.empty());
                PhaseModule.mc.player.noClip = true;
                break;
            }
            case CLIMB: {
                if (PhaseModule.mc.player.horizontalCollision) {
                    event.cancel();
                    event.setVoxelShape(VoxelShapes.empty());
                }
                if (!PhaseModule.mc.player.input.sneaking && (!PhaseModule.mc.player.input.jumping || !((double)event.getPos().getY() > PhaseModule.mc.player.getY()))) break;
                event.cancel();
            }
        }
    }

    @EventListener
    public void onPlayerUpdate(UpdateWalkingEvent event) {
        if (event.getStage() != EventStage.PRE) {
            return;
        }
        switch (this.modeConfig.getValue()) {
            case NORMAL: {
                if (!PhaseModule.mc.player.isSneaking() || !this.isPhasing()) break;
                float yaw = PhaseModule.mc.player.getYaw();
                PhaseModule.mc.player.setBoundingBox(PhaseModule.mc.player.getBoundingBox().offset((double)this.distanceConfig.getValue().floatValue() * Math.cos(Math.toRadians(yaw + 90.0f)), 0.0, (double)this.distanceConfig.getValue().floatValue() * Math.sin(Math.toRadians(yaw + 90.0f))));
                break;
            }
            case SAND: {
                MovementUtil.setMotionY(0.0);
                if (mc.isWindowFocused()) {
                    if (PhaseModule.mc.player.input.jumping) {
                        MovementUtil.setMotionY(PhaseModule.mc.player.getVelocity().y + 0.3);
                    }
                    if (PhaseModule.mc.player.input.sneaking) {
                        MovementUtil.setMotionY(PhaseModule.mc.player.getVelocity().y - 0.3);
                    }
                }
                PhaseModule.mc.player.noClip = true;
            }
        }
    }

    @EventListener
    public void onPushOutOfBlocks(PushOutOfBlocksEvent event) {
        event.cancel();
    }

    public boolean isPhasing() {
        Box bb = PhaseModule.mc.player.getBoundingBox();
        for (int x = MathHelper.floor(bb.minX); x < MathHelper.floor(bb.maxX) + 1; ++x) {
            for (int y = MathHelper.floor(bb.minY); y < MathHelper.floor(bb.maxY) + 1; ++y) {
                for (int z = MathHelper.floor(bb.minZ); z < MathHelper.floor(bb.maxZ) + 1; ++z) {
                    if (!PhaseModule.mc.world.getBlockState(new BlockPos(x, y, z)).blocksMovement() || !bb.intersects(new Box(x, y, z, (double)x + 1.0, (double)y + 1.0, (double)z + 1.0))) continue;
                    return true;
                }
            }
        }
        return false;
    }

    public enum SwapMode {
        OFF,
        NORMAL,
        SILENT,
        Inventory,
        Pick

    }

    public enum PhaseMode {
        NORMAL,
        SAND,
        CLIMB,
        PEARL

    }
}
